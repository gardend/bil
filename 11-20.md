# Билеты 11-20

## Билет 11. Однопроходный алгоритм вычисления СКО.

СКО - среднеквадратичное отклонение.

Реализация:
```julia
"""Алгоритм вычисления среднего квадратического отклонения от среднего значения массива"""
function standard_deviation(A)
    Sx = 0
    Sx2 = 0
    for i in firstindex(A):lastindex(A)
        Sx += i
        Sx2 += i*i
    end
    return sqrt((Sx2 / length(A)) - ((Sx/ length(A))*(Sx/ length(A))))
end
```

## Билет 12.  Инвариант цикла. Быстрая сортировка Хоара.

Инвариантом цикла (с предусловием) называют утверждение (предикат), зависящее от фазовых переменных цикла (т.е. переменнных, которые могут изменяться в теле цикла), имеющее значение "истина" как до начала цикла, так и после любого числа его повторений.

### Быстрая сортировка Хоара

В среднем $O(n*log(n))$. 

Общая идея алгоритма состоит в следующем:

- Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность.
- Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующих друг за другом: «элементы меньшие опорного», «равные» и «большие».
- Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.

Инвариант цикла:

Пусть величины $K, M, L$ (индексы массива $A$) такие, что

- $\forall i \in 1:K \ \ \ A[i]<b$
- $\forall i \in K+1:L \ \ \ A[i]==b$
- $\forall i \in M+1:N \ \ \ A[i]>b$


Реализация:
```julia
function quick_sort!(A)
    if isempty(A)
        return A
    end
    N = length(A)
    K, M = part_sort!(A, rand(1:N)) # - "базовый" элемент массива выбирается случайнам образом
    quick_sort!(A[1:K])
    quick_sort!(A[M:N])
    return A
end

function part_sort!(A, b)
    N = length(A)
    K=0
    L=0
    M=N
    #ИНВАРИАНТ: A[1:K] < b && A[K+1:L] == b && A[M+1:N] > b
    while L < M 
        if A[L+1] == b
            L += 1
        elseif A[L+1] > b
            A[L+1], A[M] = A[M], A[L+1]
            M -= 1
        else # if A[L+1] < b
            L += 1; K += 1
            A[L], A[K] = A[K], A[L]
        end
    end
    return K, M+1 
    # 1:K и M+1:N - эти диапазоны индексов определяют ещё не 
    # отсортированные части массива A
end
```

## Билет 13. Инвариант цикла. Вычисление порядковых статистик и медианы массива методом Хоара

Пусть имеется числовой массив $А$. Его $k$-ой **порядковой статистикой** называется значение $k$-го элемента этого массива, которое получилось бы после реализации процедуры сортировки массива $A$.

Однако для вычисления $k$-ой порядковой статистики ($k$ считается фиксированным) вовсе не обязательно сортировать массив. Существует алгоритм вычисления этой величины, имеющий сложность всего $O(N)$, т.е. быстрый алгоритм.

В самом деле, если индекс $k$ задан, то требуемую процедуру вычисдения $k$-ой порядковой статистики легко получить из рассмотренного выше алгоритма Хоара быстрой сортировки. В самом деле, вычисление $k$-ой порядковой статистики от процедуры сортировки Хоара будет отличаться лишь тем, что для последующей после частичной сортирвки массива дальнейшая обработка массива должна бутет производиться лишь только над одной из двух полученных его частей, а именно, той из них, диапазон индексов которой включает заданное $k$.

В результате, первая частичная сортирвка даст $O(N)$ операций сравнения, вторая - $O(N/2)$, третья - $O(N/4)$ и т.д., что в сумме составит всего $O(N)$ операций.

Если длина $N$ массива нечетная, то его **медианой** называется порядковая статистика с индексом $(N-1)/2$. В случае же четной длины массива его медианой можно считать среднее арифметическое двух порядковых статистик с индексами $N/2-1$ и $N/2+1$.

Поэтому алгоритм вычисления медианы массива также может основываться на быстром алгоритме вычисления порядковых статистик.

Медиана массива, наряду со средним (средним арифметическим) значением массива является важной статистической характеристикой содержащихся в нем данных. Например, эта характеристика более адекватно оценивает уровень доходов большинства граждан, нежели простое среднее арифметическое значение уровня доходов всех граждан.

Реализация из лекций(только нахождение порядковой статистики):
```julia
function order_statistics!(A, i)
    N = length(A)
    K, M = part_sort!(A, A[rand(1:N)]) # - "базовый" элемент массива обычно выбирается случайным образом
    if K < i < M
        return A[i]
    elseif i <= K
        return order_statistics!(@view(A[1:K]), i) 
    else # i >= M
        return order_statistics!(@view(A[M:N]), i)
    end
end
order_statistics(A, i) = order_statistics!(copy(A), i)
```
Реализация Феди (есть медиана): 
```julia
"""Вычисление k-ой порядковой статистики методом Хоара"""
function order_statistics!(A::AbstractVector{T}, i::Integer)::T where T
    function find(index_range)
        left_range, right_range = part_sort!(A, index_range, A[rand(index_range)])
        if i in left_range
            return find(left_range) 
        elseif i in right_range
            return find(right_range)
        else
            return A[i]
        end
    end
    find(firstindex(A):lastindex(A))
end

@inline function part_sort!(A, index_range::AbstractUnitRange, b)
    K, L, M = index_range[1]-1, index_range[begin]-1, index_range[end]
    @inbounds while L < M 
        if A[L+1] == b
            L += 1
        elseif A[L+1] > b
            A[L+1], A[M] = A[M], A[L+1]
            M -= 1
        else
            L += 1; K += 1
            A[L], A[K] = A[K], A[L]
        end
    end    
    return index_range[begin]:K, M+1:index_range[end]
end

"""Вычисление медианы массива"""
function median(A::AbstractVector{T})
    if length(A)%2==0
        return order_statistics!(A, length(A)/2)
    else
        return (order_statistics!(A, length(A)/2)+order_statistics!(A, length(A)/2+1))/2
    end
end
```


## Билет 14. Вычисление первых k порядковых статистик O(N) (k ститать фиксированным и много меньшим N).

Реализация из лекций:
```julia
unction minimums(array, k)
    N = length(array)
    k_minimums = sort(array[1:k])
    i = k
    # ИНВАРИАНТ: issorted(k_mins) && k_mins - содержит k наименьших элементов в array[1:i]
    while i < length(array)
        i += 1
        if array[i] < k_minimums[end]
            k_minimums[end] = array[i]
            insert_end!(k_minimums)
        end
    end
    return k_minimums
end            

function insert_end!(array)::Nothing
    j = length(array)
    while j>1 && array[j-1] > array[j]
        array[j-1], array[j] = array[j], array[j-1]
        j -= 1
    end
end
```

Федина реализация:
```julia
"""Поиск первых k наименьших элементов массива"""
function minimums(array, k)
    N = length(array)
    k_minimums = sort(array[1:k])
    i = k
    while i < length(array)
        i += 1
        if array[i] < k_minimums[end]
            k_minimums[end] = array[i]
            insert_end!(k_minimums)
        end
    end
    return k_minimums
end            

function insert_end!(array)::Nothing
    j = length(array)
    while j>1 && array[j-1] > array[j]
        array[j-1], array[j] = array[j], array[j-1]
        j -= 1
    end
end
```

## Билет 15. Двунаправленная пузырьковая сортировка. (Эта сортировка также называется сортировка перемешиванием)

При сортирвке методом "пузырька" при первом проходе максимальный элемент массива перемещается в самый его конец. После второго прохода на предпоследнем месте окажется второй по величине элемент массива, и т.д. Таким образом каждый раз остается отсортировать (тем же способом) оставшуюся часть массива (без элементов массива в его конце, уже находящихся на "своих" местах).

Тут важно на каждом новом проходе уменьшать на 1 величину верхнего предела переменного индекса массива с тем, чтобы не выполнять бесполезных сравнений в уже отсортированной части массива.

Но можно таже, сделав проход по массиву слева направо, в результате которого наибольший элемент переместится в конец, сделать затем аналогичный проход справа налево, в результате которого наименьший элемент переместился бы в начало. Таким образом, чередуя проходы слева направо с проходами справа налево, можно будет уменьшать оставшуюся неотсортированной часть массива сразу с двух сторон.

```julia
function mixersort!(a)
    i_beg = 1
    i_end = length(a)
    while i_beg < i_end
        @inbound for i in i_beg:i_end-1 # макрос @inbounds отменяет контроль выхода за пределы массива
            if a[i] > a[i+1]
                a[i], a[i+1] = a[i+1], a[i]
            end
        end
        i_end -= 1
        @inbound for i in i_end:-1:beg+1 # i меняется в сторону уменьшения (в диапазоне шаг отрицательный)
            if a[i-1] > a[i]
                a[i-1], a[i] = a[i], a[i-1]
            end
        end
        i_beg += 1
    end
    return a
end
```
## Билет 16. Сортировка Шелла

Сортировка пузырьком не только долгая, но и энергозатратная, потому что много раз нужно обменивать элементы. Число таких обменов можно попытаться уменьшить, если вначале сравнивать и, при нобходимости, менять местами не соседние элементы масива, а только отстоящие друг от друга на значительно большее расстояние. Затем это расстояние надо будет уменьшить и повторить ту же процедуру частичной сортировки массива с самого его начала. Постепенно меньшать расстояние между сравниваемыми элементами, и повторять процедуру частичной сортировки надо до тех пор, пока это расстояние не станет равным 1, т.е. пока, наконец, не начнут сравниваться соседние элементы массива.

В случае классической сортировки Шелла, базирующейся на сортировке вставками, в классическом её вариантк, это расстояние каждый раз уменьшается вдвое (приблизительно). При достижении расстояния между элементами равным 1 и после последнего выполнеиия сотрировки вставками уже всего массива, массив, очевидно, окажется отсортированным. Однако количество потребовавшихся при этом перестановок соседних элементов массива будет уже относительно небольшим, так все самые большие элементы ранее уже оказались перемещенными ближе к концу массива.


